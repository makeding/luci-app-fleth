#!/bin/sh
# author: huggy<fleth@huggy.moe>

DNS_E=2404:1a8:7f01:a::3
DNS_W=2001:a7ff:5f01::a

# MAP.sh paths
MAPSH_PATH="/lib/netifd/proto/map.sh"
MAPSH_BACKUP_PATH="/lib/netifd/proto/map.sh.flethbak"

# Commands that don't require UCI configuration
if [ "$1" = "hook_none.js" ] || [ "$1" = "restore_none.js" ]; then
    # Skip UCI configuration checks for these commands
    :
else
    # Note: UCI variables are not validated here as malicious modification
    h_ENABLED=$(uci get fleth.global.enabled 2>/dev/null)
    h_TUNNEL_INTERFACE=$(uci get fleth.global.interface 2>/dev/null)
    h_TUNNEL_INTERFACE_MTU=$(uci get fleth.global.mtu 2>/dev/null)
    h_TUNNEL_INTERFACE_zone=$(uci get fleth.global.interface_zone 2>/dev/null)
    h_UPLINK_INTERFACE=$(uci get fleth.global.interface6 2>/dev/null)

    if [ -z "$h_ENABLED" ] || [ -z "$h_TUNNEL_INTERFACE" ] || [ -z "$h_TUNNEL_INTERFACE_MTU" ] || [ -z "$h_UPLINK_INTERFACE" ]; then
        echo "Failed to retrieve one or more configuration values"
        exit 1
    fi
fi

# real xxxx
r_TYPE="UNKNOWN"
# DS-Lite
r_AFTR=""
r_AFTR_DOMAIN="UNKNOWN"
# map-e
r_PEERADDR=""
r_IPADDR=""
r_IP4PREFIXLEN=""
r_IP6PREFIX=""
r_IP6PREFIXLEN=""
r_EALEN=""
r_PSIDLEN=""
r_OFFSET=""


e_AREA="UNKNOWN"

get_area(){
    # east or west
    if [ -f /tmp/resolv.conf.d/resolv.conf.auto ]; then
        if grep -q "flets-east.jp" /tmp/resolv.conf.d/resolv.conf.auto; then
            e_AREA="EAST"
            DNS=$DNS_E
        elif grep -q "flets-west.jp" /tmp/resolv.conf.d/resolv.conf.auto; then
            e_AREA="WEST"
            DNS=$DNS_W
        fi
    fi
    if [ "$e_AREA" = "UNKNOWN" ]; then
        wget --timeout=1 -s "http://[2404:1a8:f401:100::1]/l/__healthcheck" -O /tmp/null > /dev/null 2>&1
        if [ $? -eq 0 ]; then
            e_AREA="EAST"
            DNS=$DNS_E
        else
            wget --timeout=1 -s "http://[2001:a7ff:ff0e:1::2]/l/__healthcheck" -O /tmp/null > /dev/null 2>&1
            if [ $? -eq 0 ]; then
                e_AREA="WEST"
                DNS=$DNS_W
            fi
        fi
    fi
    
    echo $e_AREA
}

get_pending_status(){
    # Check if IPv6 address is in specific ranges to determine pending status
    local ipv6=$(get_uplink_interface_ipv6)
    if [ -n "$ipv6" ]; then
        # East: 2001:c90::/32, 2404:1a8::/32, 2408::/22
        # https://bgp.he.net/net/2408::/22#_rdap
        if echo "$ipv6" | grep -qE '^2001:c90:|^2404:1a8:|^2408:([0-3][0-9a-f]{0,2})?:'; then
            logger -t fleth "Detected East IPv6 address in pending state: $ipv6"
            echo "EAST_pending"
            return
        # West: 2001:d70::/30, 2001:a000::/21
        elif echo "$ipv6" | grep -qE '^2001:d7[0-3]:|^2001:a0[0-7]'; then
            logger -t fleth "Detected West IPv6 address in pending state: $ipv6"
            echo "WEST_pending"
            return
        fi
    fi
    echo ""
}

get_AAAA_record() {
    local domain=$1
    result=$(nslookup -type=AAAA $domain $DNS 2>/dev/null | grep "Address:")
    if [ -n "$result" ]; then
        # get line=2
        echo "$result" | awk 'NR==2' | awk '{print $2}'
    else
        echo ""
    fi
}

check_ipv6_reachability() {
    local ip=$1
    if ping6 -c 1 -w 2 "$ip" > /dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

check_interface_proto_invalid() {
    local status=$(ifstatus $1 2>/dev/null)
    if echo "$status" | grep -q '"proto": "none"'; then
        return 0
    else
        return 1
    fi
}

get_uplink_interface_ipv6() {
    ipv6_address=$(ifstatus ${h_UPLINK_INTERFACE} | grep '"address"' | awk -F '"' '{print $4}' | grep -vE '^(fe80|fc00|fd00|fd50|::|::1|::ffff:0:0|::/96)' | head -n 1)
    echo $ipv6_address
}

get_uplink_prefix_length() {
    # Get IPv6 prefix length from interface status
    # Returns prefix length (56 or 64) or empty if not detected
    local status=$(ifstatus ${h_UPLINK_INTERFACE} 2>/dev/null)

    # Try 1: Get from ipv6-prefix (PD mode, typically /56)
    local prefix_len=$(echo "$status" | jsonfilter -e '@["ipv6-prefix"][0].mask' 2>/dev/null)
    if [ -n "$prefix_len" ]; then
        echo "$prefix_len"
        return
    fi

    # Try 2: Get from ipv6-address (SLAAC mode, typically /64)
    prefix_len=$(echo "$status" | jsonfilter -e '@["ipv6-address"][0].mask' 2>/dev/null)
    if [ -n "$prefix_len" ]; then
        echo "$prefix_len"
        return
    fi

    # Try 3: Fallback to route info
    prefix_len=$(echo "$status" | jsonfilter -e '@.route[0].mask' 2>/dev/null)
    if [ -n "$prefix_len" ]; then
        echo "$prefix_len"
        return
    fi
}

auto_setup_ipv6_mode() {
    # Automatically detect and configure IPv6 mode based on prefix length
    local prefix_len=$(get_uplink_prefix_length)

    if [ -z "$prefix_len" ]; then
        logger -t fleth "Unable to detect IPv6 prefix length, skipping auto IPv6 mode configuration"
        return 1
    fi

    logger -t fleth "Detected IPv6 prefix length: /$prefix_len"

    if [ "$prefix_len" = "56" ]; then
        logger -t fleth "Detected /56 prefix, configuring PD mode"
        $0 setup_ipv6_pd
    elif [ "$prefix_len" = "64" ]; then
        logger -t fleth "Detected /64 prefix, configuring SLAAC mode"
        $0 setup_ipv6_slaac
    else
        logger -t fleth "Unexpected prefix length /$prefix_len, skipping auto configuration"
        return 1
    fi
}

auto_configure_extendprefix() {
    # Automatically configure extendprefix based on IPv6 prefix length
    # /56 (PD mode) - extendprefix should NOT be set
    # /64 (SLAAC mode) - extendprefix should be set to 1
    local prefix_len=$(get_uplink_prefix_length)

    if [ -z "$prefix_len" ]; then
        logger -t fleth "Unable to detect IPv6 prefix length, skipping extendprefix auto-configuration"
        return 1
    fi

    local current_extendprefix=$(uci get network.${h_UPLINK_INTERFACE}.extendprefix 2>/dev/null)
    local config_changed=0

    if [ "$prefix_len" = "56" ]; then
        # For /56 (PD mode), extendprefix should NOT be set
        if [ -n "$current_extendprefix" ]; then
            logger -t fleth "Detected /56 prefix, removing extendprefix from ${h_UPLINK_INTERFACE}"
            uci delete network.${h_UPLINK_INTERFACE}.extendprefix 2>/dev/null
            config_changed=1
        fi
    elif [ "$prefix_len" = "64" ]; then
        # For /64 (SLAAC mode), extendprefix should be set to 1
        if [ "$current_extendprefix" != "1" ]; then
            logger -t fleth "Detected /64 prefix, setting extendprefix=1 on ${h_UPLINK_INTERFACE}"
            uci set network.${h_UPLINK_INTERFACE}.extendprefix=1
            config_changed=1
        fi
    fi

    # Only commit and restart if configuration changed
    if [ "$config_changed" = "1" ]; then
        uci commit network
        logger -t fleth "Restarting ${h_UPLINK_INTERFACE} due to extendprefix configuration change"
        ifdown ${h_UPLINK_INTERFACE} && sleep 2 && ifup ${h_UPLINK_INTERFACE}
    fi

    return 0
}

# https://ipv4.web.fc2.com/map-e.html
get_mape_provider() {
    # I can't rewritten calc logic with shell, asking lua for help
    t_DATA=$(lua /usr/sbin/fleth-map-e.lua calc "$ipv6_address")
    # kanashii code kana
    # yo ku wa ka ra na i
    printf "%s" "$t_DATA"
    if [ "$t_DATA" != "UNKNOWN" ]; then
        t_i=0
        while IFS= read -r line; do
            t_i=$((t_i + 1))
            case "$t_i" in
                3) r_PEERADDR=$line ;;
                4) r_IPADDR=$line ;;
                5) r_IP4PREFIXLEN=$line ;;
                6) r_IP6PREFIX=$line ;;
                7) r_IP6PREFIXLEN=$line ;;
                8) r_EALEN=$line ;;
                9) r_PSIDLEN=$line ;;
                10) r_OFFSET=$line ;;
            esac
        done << EOF
$t_DATA
EOF
        r_TYPE="map-e"
    fi
}

# https://qiita.com/site_u/items/b6d5097f5e3a0f91c95d
get_dslite_provider(){
    # check type with DS-LITE
    # 1. transix can't be resolved outside
    t_TRANSIX=$(get_AAAA_record "gw.transix.jp")
    if [ -n "$t_TRANSIX" ]; then
        r_TYPE="ds-lite"
        r_AFTR=$t_TRANSIX
        r_AFTR_DOMAIN="gw.transix.jp"
    else
        # 2. xpass can be resolved outside but can't ping
        # http://checkv6.xpass.jp/check_address.php
        t_XPASS=$(get_AAAA_record "dgw.xpass.jp")
        if check_ipv6_reachability $t_XPASS; then
            r_TYPE="ds-lite"
            r_AFTR=$t_XPASS
            r_AFTR_DOMAIN="dgw.xpass.jp"
        else
            # 3. v6connect can't be resolved outside
            # curl http://route6.asahi-net.jp/v1/address
            t_ASAHI=$(get_AAAA_record "dslite.v6connect.net")
            if [ -n "$t_ASAHI" ]; then
                r_TYPE="ds-lite"
                r_AFTR=$t_ASAHI
                r_AFTR_DOMAIN="dslite.v6connect.net"
            fi
        fi
    fi
    echo $r_AFTR
}

set_interface() {
    current_proto=$(uci get network.${h_TUNNEL_INTERFACE}.proto 2>/dev/null)
    current_tunlink=$(uci get network.${h_TUNNEL_INTERFACE}.tunlink 2>/dev/null)
    current_mtu=$(uci get network.${h_TUNNEL_INTERFACE}.mtu 2>/dev/null)
    current_zone_index=$(uci show firewall | grep -E "firewall.@zone\[[0-9]+\].network=.*'$h_TUNNEL_INTERFACE'" | sed -n "s/.*@zone\[\([0-9]\+\)\].*/\1/p")
    new_zone_index=$(uci show firewall | grep -E "firewall.@zone\[[0-9]+\].name='$h_TUNNEL_INTERFACE_zone'" | sed -n "s/.*@zone\[\([0-9]\+\)\].*/\1/p")

    if [ "$r_TYPE" = 'ds-lite' ]; then
        if [ -z "$r_AFTR" ] || [ -z "$h_TUNNEL_INTERFACE" ] || [ -z "$h_TUNNEL_INTERFACE_MTU" ] || [ -z "$h_UPLINK_INTERFACE" ]; then
            echo "Failed to retrieve one or more configuration values"
            exit 1
        fi
        current_peeraddrdomain=$(uci get network.${h_TUNNEL_INTERFACE}.peeraddrdomain 2>/dev/null)
        if [ "$current_peeraddrdomain" != "$r_AFTR_DOMAIN" ] ||
           [ "$current_tunlink" != "$h_UPLINK_INTERFACE" ] ||
           [ "$current_proto" != 'dslite' ] ||
           [ "$current_mtu" != "$h_TUNNEL_INTERFACE_MTU" ]; then
            uci batch <<EOF
set network.${h_TUNNEL_INTERFACE}=interface
set network.${h_TUNNEL_INTERFACE}.proto='dslite'
set network.${h_TUNNEL_INTERFACE}.peeraddr='${r_AFTR}'
set network.${h_TUNNEL_INTERFACE}.peeraddrdomain='${r_AFTR_DOMAIN}'
set network.${h_TUNNEL_INTERFACE}.tunlink='${h_UPLINK_INTERFACE}'
set network.${h_TUNNEL_INTERFACE}.mtu='${h_TUNNEL_INTERFACE_MTU}'
set network.${h_TUNNEL_INTERFACE}.encaplimit='ignore'
EOF
            uci delete network.${h_TUNNEL_INTERFACE}.device 2>/dev/null
            if [ "$new_zone_index" != "$current_zone_index" ]; then
                uci del_list firewall.@zone[$current_zone_index].network="$h_TUNNEL_INTERFACE" 2>/dev/null
                uci add_list firewall.@zone[$new_zone_index].network="$h_TUNNEL_INTERFACE" 2>/dev/null
            fi
            uci commit
            ifdown ${h_TUNNEL_INTERFACE} && sleep 2 && ifup ${h_TUNNEL_INTERFACE}
            logger -t fleth "New ds-lite configuratin committed ${h_TUNNEL_INTERFACE}=${r_AFTR}"
        fi
    elif [ "$r_TYPE" = 'map-e' ]; then
        current_peeraddr=$(uci get network.${h_TUNNEL_INTERFACE}.peeraddr 2>/dev/null)
        current_ipaddr=$(uci get network.${h_TUNNEL_INTERFACE}.ipaddr 2>/dev/null)
        current_ip4prefixlen=$(uci get network.${h_TUNNEL_INTERFACE}.ip4prefixlen 2>/dev/null)
        current_ip6prefix=$(uci get network.${h_TUNNEL_INTERFACE}.ip6prefix 2>/dev/null)
        current_ip6prefixlen=$(uci get network.${h_TUNNEL_INTERFACE}.ip6prefixlen 2>/dev/null)
        current_ealen=$(uci get network.${h_TUNNEL_INTERFACE}.ealen 2>/dev/null)
        current_psidlen=$(uci get network.${h_TUNNEL_INTERFACE}.psidlen 2>/dev/null)
        current_offset=$(uci get network.${h_TUNNEL_INTERFACE}.offset 2>/dev/null)
        if [ "$current_peeraddr" != "$r_PEERADDR" ] ||
            [ "$current_tunlink" != "$h_UPLINK_INTERFACE" ] ||
            [ "$current_proto" != 'map' ] ||
            [ "$current_mtu" != "$h_TUNNEL_INTERFACE_MTU" ] ||
            [ "$current_ipaddr" != "$r_IPADDR" ] ||
            [ "$current_ip4prefixlen" != "$r_IP4PREFIXLEN" ] ||
            [ "$current_ip6prefix" != "$r_IP6PREFIX" ] ||
            [ "$current_ip6prefixlen" != "$r_IP6PREFIXLEN" ] ||
            [ "$current_ealen" != "$r_EALEN" ] ||
            [ "$current_psidlen" != "$r_PSIDLEN" ] ||
            [ "$current_offset" != "$r_OFFSET" ]; then
            uci batch <<EOF
set network.${h_TUNNEL_INTERFACE}=interface
set network.${h_TUNNEL_INTERFACE}.proto='map'
set network.${h_TUNNEL_INTERFACE}.maptype='map-e'
set network.${h_TUNNEL_INTERFACE}.peeraddr='${r_PEERADDR}'
set network.${h_TUNNEL_INTERFACE}.ipaddr='${r_IPADDR}'
set network.${h_TUNNEL_INTERFACE}.ip4prefixlen='${r_IP4PREFIXLEN}'
set network.${h_TUNNEL_INTERFACE}.ip6prefix='${r_IP6PREFIX}'
set network.${h_TUNNEL_INTERFACE}.ip6prefixlen='${r_IP6PREFIXLEN}'
set network.${h_TUNNEL_INTERFACE}.ealen='${r_EALEN}'
set network.${h_TUNNEL_INTERFACE}.psidlen='${r_PSIDLEN}'
set network.${h_TUNNEL_INTERFACE}.offset='${r_OFFSET}'

set network.${h_TUNNEL_INTERFACE}.tunlink='${h_UPLINK_INTERFACE}'
set network.${h_TUNNEL_INTERFACE}.mtu='${h_TUNNEL_INTERFACE_MTU}'
set network.${h_TUNNEL_INTERFACE}.legacymap='1'
set network.${h_TUNNEL_INTERFACE}.encaplimit='ignore'
EOF
            uci delete network.${h_TUNNEL_INTERFACE}.device 2>/dev/null
            if [ "$new_zone_index" != "$current_zone_index" ]; then
                uci del_list firewall.@zone[$current_zone_index].network="$h_TUNNEL_INTERFACE" 2>/dev/null
                uci add_list firewall.@zone[$new_zone_index].network="$h_TUNNEL_INTERFACE" 2>/dev/null
            fi
            uci commit
            ifdown ${h_TUNNEL_INTERFACE} && sleep 2 && ifup ${h_TUNNEL_INTERFACE}
            logger -t fleth "New map-e configuratin committed ${h_TUNNEL_INTERFACE}=${r_PEERADDR}"
        fi
    elif [ "$new_zone_index" != "$current_zone_index" ]; then
        uci del_list firewall.@zone[$current_zone_index].network="$h_TUNNEL_INTERFACE" 2>/dev/null
        uci add_list firewall.@zone[$new_zone_index].network="$h_TUNNEL_INTERFACE" 2>/dev/null
        uci commit firewall
    fi
    if check_interface_proto_invalid ${h_TUNNEL_INTERFACE}; then
        logger -t fleth "Network Restarting"
        /etc/init.d/network restart
    fi
}

if [ "$1" = "auto" ]; then
    logger -t fleth "is running $h_ENABLED"
    if [ "$h_ENABLED" == "1" ]; then
        get_uplink_interface_ipv6 > /dev/null
        get_mape_provider > /dev/null
        if [ "$r_TYPE" = "UNKNOWN" ]; then
            get_area > /dev/null
            get_dslite_provider > /dev/null
        fi
        if [ "$r_TYPE" = "UNKNOWN" ]; then
            logger -t fleth "Can't detect network type ${h_UPLINK_INTERFACE}=${ipv6_address}"
        else
            set_interface
            auto_configure_extendprefix
        fi
    fi

elif [ "$1" = "mape_status" ]; then
    get_uplink_interface_ipv6 > /dev/null
    get_mape_provider
elif [ "$1" = "get_area" ]; then
    get_area > /dev/null
    echo ${e_AREA}
elif [ "$1" = "get_dslite_provider" ]; then
    get_area > /dev/null
    get_dslite_provider > /dev/null
    echo $r_AFTR_DOMAIN
elif [ "$1" = "pending_status" ]; then
    get_pending_status
elif [ "$1" = "get_prefix_length" ]; then
    prefix_len=$(get_uplink_prefix_length)
    if [ -n "$prefix_len" ]; then
        echo "/$prefix_len"
    else
        echo "UNKNOWN"
    fi
elif [ "$1" = "auto_setup_ipv6" ]; then
    auto_setup_ipv6_mode
elif [ "$1" = "mapsh_status" ]; then
    # Check if map.sh is patched or original
    if [ ! -f "$MAPSH_BACKUP_PATH" ]; then
        echo "original"
    elif cmp -s "$MAPSH_PATH" "$MAPSH_BACKUP_PATH"; then
        echo "original"
    else
        echo "patched"
    fi
elif [ "$1" = "hook_none.js" ]; then
    if ! grep -q 'fleth-hook.js' /www/luci-static/resources/protocol/none.js; then
        $0 restore_none.js
        sed -i "s|return|if(location.pathname==='/cgi-bin/luci/admin/network/firewall/forwards'){try{const script=document.createElement('script');script.src='/luci-static/resources/view/fleth-hook.js';document.head.appendChild(script);}catch(error){console.warn(error);}}return|" /www/luci-static/resources/protocol/none.js
    fi
elif [ "$1" = "restore_none.js" ]; then
    printf "'use strict';'require network';return network.registerProtocol('none',{getI18n:function(){return _('Unmanaged');}});" > /www/luci-static/resources/protocol/none.js
elif [ "$1" = "setup_ipv6_slaac" ]; then
    # Configure IPv6 SLAAC for NEXT(1Gbps) without Hikari Denwa (/64)
    logger -t fleth "Starting IPv6 SLAAC configuration"

    # Configure uplink interface settings
    uci batch <<EOF
set network.${h_UPLINK_INTERFACE}.reqaddress='try'
del network.${h_UPLINK_INTERFACE}.reqprefix
del network.${h_UPLINK_INTERFACE}.ip6assign
set dhcp.${h_UPLINK_INTERFACE}=dhcp
set dhcp.${h_UPLINK_INTERFACE}.interface='${h_UPLINK_INTERFACE}'
set dhcp.${h_UPLINK_INTERFACE}.master='1'
set dhcp.${h_UPLINK_INTERFACE}.ra='relay'
set dhcp.${h_UPLINK_INTERFACE}.ndp='relay'
del dhcp.${h_UPLINK_INTERFACE}.dhcpv6
EOF

    # Configure lan interface for DHCP server with IPv6
    uci batch <<EOF
set network.lan.delegate='1'
set network.lan.ip6assign='64'
set dhcp.lan=dhcp
set dhcp.lan.interface='lan'
set dhcp.lan.leasetime='6h'
set dhcp.lan.dhcpv4='server'
set dhcp.lan.ndp='relay'
set dhcp.lan.ra='server'
set dhcp.lan.ra_default='2'
del dhcp.lan.ra_flags
add_list dhcp.lan.ra_flags='managed-config'
add_list dhcp.lan.ra_flags='other-config'
set dhcp.lan.dhcpv6='server'
EOF

    # Commit changes
    uci commit network
    uci commit dhcp
    logger -t fleth "Restarting lan AND ${h_UPLINK_INTERFACE} interface"
    ifdown lan && ifup lan &
    ifdown ${h_UPLINK_INTERFACE} && sleep 2 && ifup ${h_UPLINK_INTERFACE}
    logger -t fleth "Restarting odhcpd"
    /etc/init.d/odhcpd restart
    logger -t fleth "IPv6 SLAAC configuration completed successfully"
    echo "SUCCESS"
elif [ "$1" = "setup_ipv6_pd" ]; then
    # Configure IPv6 PD for enterprise or multi-subnet scenarios (/56)
    logger -t fleth "Starting IPv6 PD configuration"

    uci batch <<EOF
set network.${h_UPLINK_INTERFACE}.reqprefix='auto'
set network.${h_UPLINK_INTERFACE}.reqaddress='try'
set network.${h_UPLINK_INTERFACE}.ip6assign='64'
set dhcp.${h_UPLINK_INTERFACE}=dhcp
set dhcp.${h_UPLINK_INTERFACE}.interface='${h_UPLINK_INTERFACE}'
set dhcp.${h_UPLINK_INTERFACE}.master='1'
del dhcp.${h_UPLINK_INTERFACE}.ra
set dhcp.${h_UPLINK_INTERFACE}.dhcpv6='relay'
del dhcp.${h_UPLINK_INTERFACE}.ndp
EOF

    # Configure lan interface for DHCP server with IPv6
    uci batch <<EOF

set network.lan.ip6hint='1'
set dhcp.lan=dhcp
set dhcp.lan.interface='lan'
set dhcp.lan.leasetime='6h'
set dhcp.lan.dhcpv4='server'
set dhcp.lan.ra='server'
set dhcp.lan.ra_default='2'
del dhcp.lan.ra_flags
add_list dhcp.lan.ra_flags='managed-config'
add_list dhcp.lan.ra_flags='other-config'
set dhcp.lan.dhcpv6='server'
set dhcp.lan.ra_offlink='1'
set dhcp.lan.ra_slaac='1'
del dhcp.lan.ndp
EOF

    # Commit changes
    uci commit network
    uci commit dhcp
    logger -t fleth "Restarting lan AND ${h_UPLINK_INTERFACE} interface"
    ifdown lan && ifup lan &
    ifdown ${h_UPLINK_INTERFACE} && sleep 2 && ifup ${h_UPLINK_INTERFACE}
    logger -t fleth "Restarting odhcpd"
    /etc/init.d/odhcpd restart

    logger -t fleth "IPv6 PD configuration completed successfully"
    echo "SUCCESS"
elif [ "$1" = "patch_map.sh" ]; then
    MAPSH_URL="https://raw.githubusercontent.com/fakemanhk/openwrt-jp-ipoe/345b1d9add58cf84c3eebe235f695607a78ebcd9/map.sh.new"

    if [ ! -f "$MAPSH_BACKUP_PATH" ]; then
        cp "$MAPSH_PATH" "$MAPSH_BACKUP_PATH"
        if [ $? -ne 0 ]; then
            echo "ERROR: Failed to create backup"
            exit 1
        fi
    fi
    TEMP_FILE=$(mktemp)
    if [ $? -ne 0 ]; then
        echo "ERROR: Failed to create temporary file"
        exit 1
    fi
    wget -q -O "$TEMP_FILE" "$MAPSH_URL"
    if [ $? -ne 0 ]; then
        rm -f "$TEMP_FILE"
        echo "ERROR: Failed to download"
        exit 1
    fi
    mv "$TEMP_FILE" "$MAPSH_PATH"
    if [ $? -ne 0 ]; then
        rm -f "$TEMP_FILE"
        echo "ERROR: Failed to replace file"
        exit 1
    fi
    chmod +x "$MAPSH_PATH"
    echo "SUCCESS"
elif [ "$1" = "restore_map.sh" ]; then
    # Restore original map.sh from backup
    logger -t fleth "Starting map.sh restoration"

    # Check if backup exists
    if [ ! -f "$MAPSH_BACKUP_PATH" ]; then
        echo "ERROR: Backup not found"
        exit 1
    fi

    mv "$MAPSH_BACKUP_PATH" "$MAPSH_PATH"
    if [ $? -ne 0 ]; then
        echo "ERROR: Failed to restore"
        exit 1
    fi

    logger -t fleth "map.sh restored successfully"
    echo "SUCCESS"
else
    echo "Flet'h by huggy"
    echo "Flet'h is a helper that can configure your IPv4 over IPv6 tunnel automatically in Japan."
    echo ""
    echo "Usage: fleth <command> [arguments]"
    echo ""
    echo "Tunnel Configuration Commands:"
    echo "  auto                  Configure the tunnel settings based on current state and config."
    echo ""
    echo "Status and Detection Commands:"
    echo "  pending_status        Show if the service is in pending state."
    echo "  get_area              Show the current area information (EAST/WEST)."
    echo "  get_dslite_provider   Show the current DS-Lite provider details."
    echo "  mape_status           Show the current MAP-E provider details."
    echo "  get_prefix_length     Show the detected IPv6 prefix length (/56 or /64)."
    echo "  mapsh_status          Show if map.sh is patched or original."
    echo ""
    echo "IPv6 Configuration Commands:"
    echo "  auto_setup_ipv6       Auto-detect prefix and configure PD (/56) or SLAAC (/64) mode."
    echo "  setup_ipv6_slaac      Configure IPv6 SLAAC for NEXT(1Gbps) without Hikari Denwa (/64)."
    echo "  setup_ipv6_pd         Configure IPv6 PD for CROSS(10Gbps) or with Hikari Denwa (/56)."
    echo ""
    echo "File Patches:"
    echo "  patch_map.sh          Patch map.sh with fixed version (backup created if not exists)."
    echo "  restore_map.sh        Restore original map.sh from backup."
    echo "  hook_none.js          Install the fleth hook in none.js to hook port-forward page."
    echo "  restore_none.js       Restore the none.js to its default state."
    echo ""
    echo "To modify settings, try these examples below:"
    echo "uci show fleth.global"
    echo "uci set fleth.global.enabled=1"
    echo "uci commit"
    echo ""
    echo "For more details, consult the documentation:"
    echo "https://fleth.huggy.moe/"
fi
